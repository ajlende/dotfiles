setopt localoptions extended_glob

local sgr_pattern=$'\e\\[[0-9;]*m'

local jjaction jjbranch jjbase jjstaged jjunstaged jjrevision jjmisc
local -a output

jjbase=${vcs_comm[basedir]}

output=("${(0)$(${vcs_comm[cmd]} log --ignore-working-copy -n 1 --no-graph --color never \
  -r "coalesce(ancestors(present(@)) & bookmarks(), root())" \
  -T 'separate("\0",
        if(root, "root()", bookmarks.map(|b| b.name()).join(" ")),
        if(bookmarks.any(|b| !b.synced()), "true", "false"),
        if(!current_working_copy, "true", "false"),
      )' 2>/dev/null)}")
output+=("${(0)$(${vcs_comm[cmd]} log --ignore-working-copy -n 1 --no-graph --color always \
  -r "coalesce(present(@), root())" \
  -T 'separate("\0",
        change_id.shortest(8),
        if(description, description.first_line(), label(if(empty, "empty"), description_placeholder)),
        if(empty, empty_commit_marker, format_commit_labels(self)),
      )' 2>/dev/null)}")

output=("${(@)output//\%/%%}")
output=("${(@)output//\$/\\\$}")
output=("${(@)output//\`/\\\`}")
output=(${(S)output//(#m)${~sgr_pattern}/%{$MATCH%}})

jjbranch=${output[1]}
jjunstaged=${output[2]#false}
jjstaged=${output[3]#false}
jjrevision=${output[4]}
jjmisc=${output[5]}
jjaction=${output[6]}

# | %a | action   | label   | (empty), (conflict), (hidden), (divergent) |
# | %b | branch   | string  | first bookmark ancestor name               |
# | %R | base     | string  | full path to the base directory            |
# | %c | staged   | boolean | true if working copy is ahead of bookmark  |
# | %u | unstaged | boolean | true if bookmark is out of sync            |
# | %i | revision | label   | 8 character change_id, formatted           |
# | %m | misc     | label   | first line of description, formatted       |

VCS_INFO_formats "${jjaction}" "${jjbranch}" "${jjbase}" "${jjstaged}" "${jjunstaged}" "${jjrevision}" "${jjmisc}"
